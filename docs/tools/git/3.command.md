# 常用命令



## 撤销操作

参考 [撤销操作](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C)

有的时候commit之后发现还有文件忘记add了那么可以使用--amend选项来重新提交:

~~~ shell

git commit --amend

~~~

例如：

~~~ shell

$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend

~~~

最终你只会有一个提交——第二次提交将代替第一次提交的结果。

### 取消暂存文件

::: tip
撤销操作中的demo使用了git status提示的`git reset HEAD <file>... `和` git checkout -- <file>`来取消暂存以及还原本地修改，实际操作时`git status`统一给予的提示为`git resotre`

`git resotre`为Git 2.23中添加的新命令
:::


当一个文件我们通过add命令加入暂存区之后，如果想要取消该如何操作？

`git status`命令提示了我们：

~~~ shell

git add docs/tools/git/3.command.md
git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   docs/tools/git/3.command.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   docs/.vuepress/config.js
	modified:   docs/.vuepress/config/pluginsConf.js
	modified:   docs/.vuepress/config/sidebarConf.js
	modified:   docs/ops/os/mac/3.software.md
	modified:   docs/tools/git/README.md
	
~~~

`Changes to be committed:`文字下方，提示使用`git restore --staged `来取消暂存，实际操作中我们可以通过`git status`命令提示来进行相关操作

**Git-Book 撤销章节**中的样例使用来`git reset HEAD <file>... `来取消暂存

::: warning
git reset 确实是个危险的命令，如果加上了 --hard 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。

我们需要对`git reset`进行更加深入对了解，阅读官方[重置揭秘](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86#_git_reset)
:::


### 撤消对文件的修改

如果我们不想保留对`CONTRIBUTING.md`文件对修改，想要将它还原成上次提交对样子，也可以通过`git status`的提示来进行操作

~~~ shell
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
~~~

它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：

~~~ shell
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
~~~

可以看到那些修改已经被撤消了。

::: warning

请务必记得` git checkout -- <file>` 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。
:::

如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 Git 分支 介绍保存进度与分支，这通常是更好的做法。

记住，在 Git 中任何 已提交 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 --amend 选项覆盖的提交也可以恢复 （阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。


## 重置揭秘

[Git-重置揭秘](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86#_git_reset)

Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：

|  树    |   用途   |
| ---- | ---- |
|  HEAD    |   上一次提交的快照，下一次提交的父结点   |
|   Index   |   预期的下一次提交的快照   |
|   Working Directory   |   沙盒   |

**HEAD**
HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。

其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：

~~~ shell

$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
~~~
Git 的 `cat-file` 和 `ls-tree` 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。

索引

索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 git commit 时 Git 看起来的样子。

`git add fileName`来获取工作目录中的内容，并将其复制到索引中（将工作区文件加入暂存区）。

`git commit` 它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。


reset作用：

1. 移动HEAD
移动HEAD的指向，这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 

这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。

一般会先使用`reset --soft 上一个快照版本`，实际上是撤销了上一次提交（可以通过git log查看快照版本）

`HEAD~`表示HEAD的父节点，执行`reset HEAD~`实际上是把该分支移动回原来的位置，而不会改变索引和工作目录。


2. 更新索引（--mixed）

--mixed是默认行为

案例中`git reset HEAD~`未指定--mixed选项，实际等价于`git reset --mixed HEAD~`

它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。

3. 更新工作目录（--hard）

::: tip

--hard 标记是 reset 命令唯一的危险用法

其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。

在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。
:::