
## man

可使用`man man`查看

![man](https://gitee.com/zengsl/picBed/raw/master/img/20201104142411.png)

## 字体

### 查看所有字体
fc-list

### 查看中文字体
fc-list :lang=zh

### 安装步骤

~~~shell
# 将字体文件拷贝到 /usr/share/fonts/
cp xx.ttl /usr/share/fonts
# 进入字体目录
cd /usr/share/fonts
# 执行以下命令
mkfontscale
mkfontdir
~~~

## shutdown

~~~ shell
# 重启
shutdown -r

# 关机
shutdown -h

# 取消
shutdown -c

~~~


## sed

> Linux sed 命令是利用脚本来处理文本文件。
> sed 可依照脚本的指令来处理、编辑文本文件。
> Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。

有时候我们观察生产日志的时候，由于日志文件过大直接下载下来打开搜索比较困难，我们可以借助sed命令截取某个时间段段数据，如果通过文字匹配可以使用还有[cat](#cat)命令

按时间段截取日志
~~~ shell
sed -n '/2020-08-14 04:40/,/2020-08-14  04:45/p' app-005-compare.out
~~~
这里的时间根据实际日志文件中打印的时间来设置

如果想把上述内容保存到文件中
~~~ shell
sed -n '/2020-08-14 04:40/,/2020-08-14  04:45/p' app-005-compare.out > fileName
~~~

## cat
> cat 命令用于连接文件并打印到标准输出设备上。
在生产上观察某个功能的执行情况时，我们可以通过此通过此功能的一个或者多个关键字来从日志文件中匹配
~~~ shell
cat app-005-compare.out | grep -E 'key1|key2'  
~~~


## which
> Linux which命令用于查找文件。
which指令会在环境变量$PATH设置的目录里查找符合条件的文件

~~~ shell
which man
# 显示/usr/bin/man
~~~ 


## 机器配置
### 物理CPU个数 

~~~ bash
cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l # 2个
~~~



![image-20200824103119282](https://gitee.com/zengsl/picBed/raw/master/img/image-20200824103119282.png)

### CPU核心数 

~~~ bash
cat /proc/cpuinfo| grep "cpu cores"| uniq # 10核心
~~~



![image-20200814085927297](https://gitee.com/zengsl/picBed/raw/master/image-20200814085927297.png)

### 逻辑CPU个数

~~~ bash
  cat /proc/cpuinfo| grep "processor"| wc -l # 40
~~~


总核数 = 物理CPU个数 X 每颗物理CPU的核数 
总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数


### 查看系统内存情况

~~~bash
cat /proc/meminfo #32G
~~~

## top

常用指令

~~~bash
# 显示进程运行信息列表。按下P,进程按照cpu使用率排序 
top -c

# 根据PID查出消耗cpu最高的线程号(3034)，显示一个进程的线程运行信息列表。按下P,进程按照cpu使用率排序
top -Hp 3033 

# 将最耗费性能的线程号转为16进制（因为我们的java线程栈里面是使用十六进制显示的）(3034->0xbda)
# 执行jstack -l 3033 > ./3033.stack
# cat 3033.stack |grep 'bda' -C 8 查看问题代码

~~~


[参考文档](https://www.cnblogs.com/Luouy/p/10337750.html)

[参考文档](https://www.cnblogs.com/niuben/p/12017242.html)

## 性能观察

[相关命令](https://man.linuxde.net/par/3)

### proc

~~~bash
# 查看网络流量
cat /proc/net/dev

### 查看系统平均负载
cat /proc/loadavg

### 查看CPU的利用率
cat /proc/stat
~~~

### vmstat

~~~bash
# 每5秒打印一次结果
vmstat 5
~~~

![vmstat](https://gitee.com/zengsl/picBed/raw/master/img/2021/09/20210917165805.png)

第一行报告显示的是自系统启动以来的平均值

- procs 

r列显示了多少进程正在等待CPU，b列显示多少进程正在不可中断休眠（通常意味着它们在等待I/O，例如磁盘、网络、用户输入，等等）

- memory

swpd列显示多少块被换出到列磁盘（页交换）。剩下的三个列显示了多少块是空闲的（未被使用）、多少块正在被用作缓冲，以及多少正在被用作操作系统的缓存。

- swap

这些列显示页面交换活动：每秒有多少块正在被换入（从磁盘）和换出（到磁盘）。

它们比监控swpd列更重要。大部分时间我们喜欢看到si和so列是0，并且我们很明确不希望看到每秒超过10个块。突发性的高峰一样很糟糕。

- io

这些列显示有多少块从设备读取（bi）和写出（bo）。这通常反应列磁盘I/O。

- system

这些列显示列每秒中断（in）和上下文切换（cs）数量

- cpu

这些列显示所有的CPU时间花费在各类操作的百分比，包括执行用户代码（非内核）、执行系统代码（内核）、空闲，以及等待I/O。如果正在使用虚拟化，则第五个列可能是st，显示了从虚拟机中“偷走”的百分比。这关系到那些虚拟机想运行但是系统管理程序转而运行其他的对象的时间。如果虚拟机不希望运行任何对象，但是系统管理程序运行了其他对象，这不算被偷走的CPU时间。

::: tips
内存、交换区，以及I/O统计是块数而不是字节。在GNU/Linux，块大小通常是1024字节。

:::

[参考](https://man.linuxde.net/vmstat)

### iostat

默认情况下它显示了与vmstat相同的CPU使用信息。

通常只对I/O统计感兴趣，下述命令只展示扩展的设备统计：

``` shell
iostat -dx 5
```

![iostat](https://gitee.com/zengsl/picBed/raw/master/img/2021/09/20210917171000.png)

与vmstat一样，第一行报告显示的是自系统启动以来的平均值，每个设备显示一行。

- rrqm/s和wrqm/s

每秒合并的读和写请求。“合并的”意味着操作系统从队列中拿出多个逻辑请求合并为一个请求到实际磁盘。

- r/s和w/s

每秒发送到设备到读和写请求

- rsec/s和wsec/s

每秒读和写读扇区数。有些系统也输出为rkB/s和wkB/s，意为每秒读写的千字节数。

- avgrq-sz

请求的扇区数。

- avgqu-sz

在设备列中等待的请求数。

- await

磁盘排队上花费的毫秒数。很不幸，iostat没有独立统计读和写的请求，它们实际上不应该被仪器平均。当你诊断性能案例时这通常很重要。

- svctm

服务请求花费的毫秒数，不包括排队时间。

- %util

至少有一个活跃请求所占时间的百分比。如果熟悉队列理论中利用率的标准定义，那么这个命名很莫名其妙。它其实不是设备的利用率。超过一块硬盘的设备（例如RAID控制器）比一块硬盘的设备可以支持更高的并发，但是util从来不会超过100%，除非在计算时有四舍五入的错误。因此，这个指标无法真实反映设备的利用率，实际上跟文档说的相反，除非只有一块物理磁盘的特殊例子。


### free


### df



~~~ shell
# 参数 -d 表示，显示设备（磁盘）使用状态；-k某些使用block为单位的列强制使用Kilobytes为单位；1 10表示，数据显示每隔1秒刷新一次，共显示10次
iostat -d -k 1 10

# 使用-x参数我们可以获得更多统计信息,-c 参数获取CPU部分的值
~~~


### ifstat

### 测量上下文切换时长

~~~bash
Lmbench3
~~~

还有[top](#top)命令


## 网络相关

### 访问网络

- 访问百度方法一

~~~ shell
exec 8 <> /dev/tcp/www.baidu.com/80

echo "GET / HTTP/1.0\n"

echo -e "GET / HTTP/1.0\n"

# 标准输出重定向至文件描述符8

echo -e "GET / HTTP/1.0\n" 1>& 8
~~~

- 访问百度方法二

~~~ shell
curl www.baidu.com
~~~

- 访问百度方法三

~~~ shell
# 建立tcp连接
nc www.baidu.com
~~~

cd /proc/$$/fd

### 抓包

~~~ shell
# 监听80端口 或者 arp协议
tcpdump -nn -i eth0 port 80 [or arp]
~~~

### 路由命令

~~~ shell
route -n
~~~

### arp命令

~~~ shell
arp
~~~

## strace

追踪系统调用
~~~ shell
strace -ff -o out java ClassName
~~~

## lsof

~~~ shell
lsof -p 11645
~~~

